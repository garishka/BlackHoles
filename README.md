# BlackHoles
Кодът на последната задача е в папка geodesic_integration_kerr.

Все още съм бавна. 

Та за момента имам:
  - Функции, които смятат първа производна на функция с една/много променливи и втора производна на много променливи. Всички използват дуални и хипердуални числа, което позволява пресмятането на производни с машинна точност.
    
    - derivative(func: Callable, x: float) ->  float
    
    - partial_deriv(func: Callable, vars: Union[list, np.ndarray], wrt_index: int, *params) -> float
    
    - second_deriv(func: Callable, x: float, *params) -> float
    
    - second_partial_deriv(func: Callable, vars: Union[list, np.ndarray], wrt_index: Union[list, np.ndarray], *params) -> float
    
  - Две функции за пресмятане на якобиана - единият използва като вход лист от новите координати като функции на старите за пресмятане, другия изпозва хамилтониана:
    
    - jacobian(new_coord: List[Callable], old_coord: Union[list, np.ndarray], *params) -> np.ndarray
    
    - jacobian_H(H, qp, *params) -> 8x8 np.ndarray (може да го напиша за по-общ случай, ако ми потрябва)
    
  - Симплектичен интегратор с възможности на интегриране от 2ри и 4ти ред:
    
    - symplectic_integrator(H, qp0, metric_params, step_size: float, omega: float, num_steps: int, ord: float) -> 2 * len(qp0) x num_steps np.ndarray
    
  - Функция за закръгляне на стойността на ъгъл, в зависимост от зададена резолюция и интервал:
    
    - discretize_angles(angles: list, resolution: int, interval=np.pi) -> tuple с (\alpha, \delta \alpha)
    
  - ... и други подобни, които не се знае дали ще използвам някъде.
    
    (Това го казвам, защото тези функции могат да се използват за неща извън сегашната задача.)
 
# Гледайте файловете "minimal_example.py", "dual.py", "integrator.py". Останалите са (още по-голяма) манджа с грозде.  
    
- Опитах се просто да променя стойностите на променливите, както оказахте в предишен имейл, но това не е основния проблем в кода.
- Дефинирах якобиан, необходим на solve_ivp за ‘Radau’, ‘BDF’ и ‘LSODA’ методите, тъй като в документацията беше споменато "It is generally recommended to provide the Jacobian rather than relying on a finite-difference approximation." (Опитвах с всички методи, не само с горе изброените.) LSODA дава грешки от типа на "too much accuracy requested for precision of machine", другите също не тръгнаха, но не съм правила screenshot-и. 
- В резултат, реших да зарежа напълно стария код и да напиша минимална работеща версия. Използвах дуални числа навсякъде където можех (още ги харесвам, съжалявам). Също не проработи.
- Написах началната версия на симплектичната схема за интегриране. Оказа се много бавна.
- Успях да използвам concurrent.futures, 4 пъти подобрение във времето тъй като имам 4 ядра на лаптопа. В този момент се фокусирах повече в оптимизиране на кода, защото върви прекалено бавно за каквито и да било сметки.
- Опитах да използвам jit, който стана популярен за оптимизиране на python код. Най-вероятно не го направих правилно, защото за метода с дуални числа кодът всъщност стана 7-8 пъти по-бавен, вместо по-бърз. (Опитвах всичко, за което се сетих)
- В началото на декември приятелят ми по щастлива случайност ми върна видео картата за компътъра и имах надежди, че мога да подкарам кода там, което ще намали времето поне два пъти. Оказа се, че не знам как да пиша git hub repository, защото кода не тръгна out of the box на компютъра и съм го оставила засега, понеже имам и други проблеми с linux на компютъра.
- Намирах още няколко грешки от недоглеждане, но сигурно има и други, защото кодът още не работи правилно. Пускала съм го поне 30 пъти (на толкова грубо имам screenshot-и) и освен, че в голяма част от случаите има напревилно отместване (i.e. наляво вместо нядясно), колкото по-висока е резолюцията, толкова по-добре се вижда, че вместо характерното сплескване, при мен се получава нещо като защипване (заострена част). Честно, не знам защо съм толкова бавна. Също на голяма част от тях има бели пиксели където не трябва. Не знам това от липса на точност ли е или от недостатъчно интеграционни стъпки.
- По едно време се опитвах да пренапиша по-голямата част на C++, въпреки минималните си знания. Очевидно не тръгна.
- Играх си с куплиращата константа на интеграционната схема и стигнах до заключението, че нищо не разбирам. Кодът не работи за \omega <0.5, за големи \omega (примерно 20), картинката прилича на някакъв шум.
- Опитах първият пример от статията на Molei Tao (DOI: 10.1103/PhysRevE.94.043303), получих същата зависимост, но много по-големи грешки. Което е по-зле, методът от 4ти ред е по-неточен от този от 2ри. Възможно е и грешно да съм estimate-нала грешките. 
